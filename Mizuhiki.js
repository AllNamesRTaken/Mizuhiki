// Generated by CoffeeScript 1.8.0
(function() {
  define(["clazzy/Clazzy", "mizuhiki/abstraction/Lang", "mizuhiki/abstraction/Dom", "mizuhiki/SoyaMilk", "clazzy/Exception", "mizuhiki/TemplatedObject"], function(Class, lang, dom, soyamilk, Exception, TemplatedObject) {
    'use strict';
    return Class("mizuhiki.Mizuhiki", null, null, {
      render: function(control) {
        return this._draw(control);
      },
      _draw: function(control, id, index, data) {
        var html, node, nodeId, _base;
        if (control != null ? control.haznt("IRendererMeta") : void 0) {
          throw new Exception("IllegalObjectException", "Control isnt a templated object. Missing IRendererMeta.");
        }
        control.set("Id", control.get("Id") || this.generateGuid());
        if (!control.get("AttachPoint")) {
          console.warn("No AttachPoint set on control " + control.get("Id") + ". Control wont be visible.");
        }
        if (id) {
          nodeId = id.replace("{{_}}", index);
        }
        if (id) {
          nodeId = nodeId.replace("{{Id}}", id);
        }
        if (nodeId && !(typeof (_base = control.domNode).querySelector === "function" ? _base.querySelector("#" + nodeId) : void 0)) {
          index = void 0;
          nodeId = void 0;
          id = void 0;
        }
        this._unbindData(control, nodeId);
        this._removeWidgets(control, nodeId);
        if (!id) {
          this._unregisterNode(control);
        }
        if (!control.IRendererMeta._dataBindings.parsed) {
          this._calculateBindings(control);
        }
        html = this._parseTemplate(control, id, index, data);
        html = this.__frameworkReplaceCustomAttributes(html);
        node = this._placeHtml(control, html, nodeId);
        if (!id) {
          node.id = control.get("Id");
        }
        if (!id) {
          this._registerNode(control);
        }
        this.__frameworkParse(node);
        this._runGenerators(control, node);
        if (control.get("AttachPoint")) {
          this._bindData(control, nodeId, node);
        }
        this._cleanDom(node);
        control.set("PreviousId", control.get("Id"));
        return control.set("PreviousAttachPoint", control.get("AttachPoint"));
      },
      generateGuid: function(withDash, checkForNodes) {
        var S4, d, guid;
        if (withDash == null) {
          withDash = false;
        }
        if (checkForNodes == null) {
          checkForNodes = true;
        }
        d = withDash ? "-" : "";
        S4 = function() {
          return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        guid = S4() + S4() + d + S4() + d + S4() + d + S4() + d + S4() + S4() + S4();
        while (checkForNodes && dom.byId(guid)) {
          guid = S4() + S4() + d + S4() + d + S4() + d + S4() + d + S4() + S4() + S4();
        }
        return guid;
      },
      _unbindData: function(control, id) {
        var handle, key, node, nodeId, _i, _len, _ref;
        nodeId = id || control.get("PreviousId") || control.get("Id");
        if (!nodeId) {
          return;
        }
        node = dom.byId(nodeId);
        if (!node) {
          return;
        }
        if (!id) {
          if (control.IRendererMeta._setterBindings._setterHandle) {
            control.IRendererMeta._setterBindings._setterHandle.remove();
            control.IRendererMeta._setterBindings._setterHandle = null;
          }
          if (control.IRendererMeta._setterBindings._domHandle) {
            lang.event.remove(control.IRendererMeta._setterBindings._domHandle);
            control.IRendererMeta._setterBindings._domHandle = null;
          }
        }
        for (key in control.IRendererMeta._attachIds[nodeId]) {
          if (key in control.IRendererMeta._attachEvents) {
            _ref = control.IRendererMeta._attachEvents[key];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              handle = _ref[_i];
              lang.event.remove(handle);
            }
          }
          (control.IRendererMeta._attachPoints[key] != null) && delete control[control.IRendererMeta._attachPoints[key]];
          (control.IRendererMeta._attachPoints[key] != null) && delete control.IRendererMeta._attachPoints[key];
          (control.IRendererMeta._attachEvents[key] != null) && delete control.IRendererMeta._attachEvents[key];
          delete control.IRendererMeta._attachIds[control.get("PreviousId") || control.get("Id")][key];
        }
        delete control.IRendererMeta._attachIds[nodeId];
        return void 0;
      },
      _removeWidgets: function(control, id) {
        var node, nodeId, _i, _len, _ref;
        nodeId = id || control.get("PreviousId") || control.get("Id");
        if (!nodeId) {
          return;
        }
        _ref = dom.findAllWidgets(nodeId);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          node.destroyRecursive();
        }
        return dom.unregisterWidget(nodeId);
      },
      _unregisterNode: function(control) {
        return dom.unregister(control.get("PreviousId") || control.get("Id"));
      },
      _calculateBindings: function(control) {
        var databound, div, i, itemId, outerHTML, prop, templateDom, _i, _j, _len, _ref, _ref1;
        outerHTML = function(node) {
          return node.outerHTML || (function(n) {
            var div, h;
            div = document.createElement('div');
            div.appendChild(n.cloneNode(true));
            h = div.innerHTML;
            div = null;
            return h;
          })(node);
        };
        templateDom = dom.create(control.get("templateString"));
        div = dom.create("<div></div>");
        div.appendChild(templateDom);
        databound = dom.find('[data-bind-to]', div);
        if (databound.length > 0) {
          for (i = _i = 0, _ref = databound.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            itemId = databound[i].id.replace("{{_}}", "_____");
            itemId = lang.trim(soyamilk.render(itemId, control, control.partials || (control.partials = {}))).replace("_____", "{{_}}");
            control.IRendererMeta._dataBindings[itemId] = {
              html: outerHTML(databound[i]),
              prop: lang.map(databound[i].getAttribute('data-bind-to').split(','), function(el) {
                return lang.trim(el);
              }),
              key: databound[i].getAttribute('data-bind-to-key')
            };
            _ref1 = control.IRendererMeta._dataBindings[itemId].prop;
            for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
              prop = _ref1[_j];
              if (!control.IRendererMeta._setterBindings[prop]) {
                control.IRendererMeta._setterBindings[prop] = [];
              }
              control.IRendererMeta._setterBindings[prop].push(itemId);
            }
          }
        }
        return control.IRendererMeta._dataBindings.parsed = true;
      },
      _parseTemplate: function(control, id, index, data) {
        var key, regex, templateString, value;
        if (id == null) {
          return lang.trim(soyamilk.render(control.get("templateString"), control, control.partials || (control.partials = {})));
        }
        templateString = index != null ? control.IRendererMeta._dataBindings[id].html.replace(/{{_}}/g, index) : control.IRendererMeta._dataBindings[id].html;
        if (index) {
          for (key in data) {
            value = data[key];
            regex = new RegExp("{{" + key + "}}");
            templateString = templateString.replace(regex, value);
          }
        }
        return lang.trim(soyamilk.render(templateString, control, control.partials || (control.partials = {})));
      },
      __frameworkReplaceCustomAttributes: function(html) {
        return html = html.replace(/data-dojo-attach/gi, "data-attach");
      },
      __frameworkParse: function(node) {
        if (node.parentNode && node.attributes["data-dojo-type"] !== void 0) {
          return dom.parse(node.parentNode);
        } else {
          return dom.parse(node);
        }
      },
      _runGenerators: function(control, node) {
        var err, f, generatorName, generatorNode, _i, _len, _ref, _results;
        try {
          _ref = dom.find("[data-generator-function]", node);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            generatorNode = _ref[_i];
            if ((f = control[generatorName = generatorNode.getAttribute("data-generator-function")]).call != null) {
              dom.replace(generatorNode, f.call(control));
              if (control[generatorName + "Startup"] != null) {
                _results.push(control[generatorName + "Startup"]());
              } else {
                _results.push(void 0);
              }
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        } catch (_error) {
          err = _error;
          throw new Exception("GeneratorException", "Generator '" + generatorName + "' was not found on " + control.get("declaredClass") + " or it markup was invalid");
        }
      },
      _placeHtml: function(control, html, id) {
        var attachPoint, domNode, idPassed, nodeId, placeNewDom, prevAttachPoint, removeDom, replaceDom, widgetId;
        nodeId = id || control.get("PreviousId");
        domNode = dom.create(html);
        if (dom.byId("widget_" + id)) {
          widgetId = "widget_" + id;
        }
        idPassed = nodeId === id;
        attachPoint = control.get("AttachPoint");
        if ("string" === typeof attachPoint) {
          attachPoint = attachPoint === "body" ? document.body : dom.byId(attachPoint);
        }
        prevAttachPoint = control.get("PreviousAttachPoint");
        if ("string" === typeof prevAttachPoint) {
          prevAttachPoint = prevAttachPoint === "body" ? document.body : dom.byId(prevAttachPoint);
        }
        removeDom = ((attachPoint == null) && (prevAttachPoint != null)) || ((attachPoint != null) && (prevAttachPoint != null) && attachPoint !== prevAttachPoint);
        replaceDom = (prevAttachPoint != null) && attachPoint === prevAttachPoint;
        placeNewDom = (attachPoint != null) && !replaceDom;
        if (removeDom) {
          dom.destroy(control.get("Id"));
        }
        if (replaceDom) {
          dom.replace((idPassed ? widgetId || nodeId : control.get("PreviousId")), domNode);
        }
        if (placeNewDom) {
          dom.place(domNode, attachPoint);
        }
        if (!id) {
          control.domNode = domNode;
        }
        return domNode;
      },
      _registerNode: function(control) {
        return dom.register(control.get("Id"), control);
      },
      _bindData: function(control, id, domNode) {
        var nodeId;
        nodeId = id || control.get("Id");
        if (!control.IRendererMeta._attachIds[control.get("Id")]) {
          control.IRendererMeta._attachIds[control.get("Id")] = {};
        }
        this._bindEvents(control, domNode, nodeId);
        this._bindAttachPoints(control, domNode, nodeId);
        if (control.IRendererMeta._setterBindings && !control.IRendererMeta._setterBindings._setterHandle) {
          control.IRendererMeta._setterBindings._setterHandle = control.watch('*', lang.hitch(this, function(prop, oldvalue, value, index, self) {
            var _i, _len, _ref;
            if (prop in control.IRendererMeta._setterBindings) {
              _ref = control.IRendererMeta._setterBindings[prop];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                nodeId = _ref[_i];
                if (nodeId.replace("{{_}}", index) !== self) {
                  this._draw(control, nodeId, index, control.get(prop)[index]);
                }
              }
            }
            return value;
          }));
          return control.IRendererMeta._setterBindings._domHandle = lang.event.on(control.domNode, 'change', this, function(evt) {
            var dataBindings, dataindex, domId, prop, propValue, _i, _len, _ref;
            domNode = evt.target || evt.srcElement;
            dataindex = domNode.getAttribute("data-index");
            domId = domNode.id;
            if (dataindex != null) {
              domId = (domId.substring(0, domId.lastIndexOf(dataindex))) + "{{_}}";
            }
            if (domId in control.IRendererMeta._dataBindings) {
              dataBindings = control.IRendererMeta._dataBindings[domId];
              _ref = dataBindings.prop;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                prop = _ref[_i];
                if (dataBindings.key == null) {
                  propValue = evt.target.value;
                } else {
                  (propValue = lang.clone(control.get(prop)[dataindex]))[dataBindings.key] = evt.target.value;
                }
                if (control.get(prop) !== evt.target.value) {
                  control.set(prop, propValue, dataindex, domNode.id);
                }
              }
              return typeof evt.cancelBubble === "function" ? evt.cancelBubble() : void 0;
            }
          });
        }
      },
      _bindEvents: function(control, domNode, nodeId) {
        var attachEventDoms, event, events, node, _getEvent, _getFunction, _i, _j, _len, _len1;
        _getEvent = function(eventString) {
          return lang.trim(eventString.substr(0, eventString.indexOf(":")));
        };
        _getFunction = function(eventString) {
          var err, func;
          func = lang.trim(eventString.substr(eventString.indexOf(":") + 1));
          if (func.indexOf(";") !== -1) {
            try {
              return new Function(func);
            } catch (_error) {
              err = _error;
              console.log(err);
            }
          }
          return func;
        };
        attachEventDoms = dom.find('[data-attach-event]', domNode.parentNode || domNode);
        for (_i = 0, _len = attachEventDoms.length; _i < _len; _i++) {
          node = attachEventDoms[_i];
          events = lang.map(node.getAttribute("data-attach-event").split(","), function(event) {
            return {
              event: _getEvent(event),
              func: _getFunction(event)
            };
          });
          if (!control.IRendererMeta._attachEvents[node.id]) {
            control.IRendererMeta._attachEvents[node.id] = [];
          }
          for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
            event = events[_j];
            if (event.event && event.func) {
              control.IRendererMeta._attachEvents[node.id].push(lang.event.on(node, this._lookupEvent(event.event), control, event.func));
            }
          }
          node.removeAttribute("data-attach-event");
          if (!control.IRendererMeta._attachIds[nodeId]) {
            control.IRendererMeta._attachIds[nodeId] = {};
          }
          control.IRendererMeta._attachIds[nodeId][node.id] = true;
          control.IRendererMeta._attachIds[control.get("Id")][node.id] = true;
        }
        return 0;
      },
      _lookupEvent: function(eventString) {
        var event;
        event = eventString;
        switch (eventString) {
          case "mouseenter":
            event = dom.mouse.enter;
            break;
          case "mouseleave":
            event = dom.mouse.leave;
        }
        return event;
      },
      _bindAttachPoints: function(control, domNode, nodeId) {
        var attachPointDoms, attachPointName, node, _i, _len, _results;
        attachPointDoms = dom.find('[data-attach-point]', domNode.parentNode || domNode);
        _results = [];
        for (_i = 0, _len = attachPointDoms.length; _i < _len; _i++) {
          node = attachPointDoms[_i];
          attachPointName = node.getAttribute("data-attach-point");
          control[attachPointName] = node;
          control.IRendererMeta._attachPoints[node.id] = attachPointName;
          node.removeAttribute("data-attach-point");
          if (!control.IRendererMeta._attachIds[nodeId]) {
            control.IRendererMeta._attachIds[nodeId] = {};
          }
          control.IRendererMeta._attachIds[nodeId][node.id] = true;
          _results.push(control.IRendererMeta._attachIds[control.get("Id")][node.id] = true);
        }
        return _results;
      },
      _cleanDom: function(domNode) {
        var node, typeAttributed, _i, _len, _results;
        typeAttributed = dom.find('[data-dojo-type]', domNode.parentNode || domNode);
        _results = [];
        for (_i = 0, _len = typeAttributed.length; _i < _len; _i++) {
          node = typeAttributed[_i];
          _results.push(node.removeAttribute('data-dojo-type'));
        }
        return _results;
      },
      destroy: function(control) {
        if (control.IRendererMeta._setterBindings._setterHandle) {
          control.IRendererMeta._setterBindings._setterHandle.remove();
        }
        if (control.IRendererMeta._setterBindings._domHandle) {
          lang.event.remove(control.IRendererMeta._setterBindings._domHandle);
        }
        this._unbindData(control);
        this._removeWidgets(control);
        this._unregisterNode(control);
        return dom.destroy(control.get("Id"));
      }
    });
  });

}).call(this);

//# sourceMappingURL=Mizuhiki.js.map
